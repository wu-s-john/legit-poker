classDiagram
    class LedgerState {
        - inner: RwLock<HashMap<HandId, AnyTableSnapshot>>
        + new()
        + snapshot(hand_id): Option<AnyTableSnapshot>
        + apply_event(envelope): Result
        + replay(events): Result
    }

    class AnyTableSnapshot {
        <<enum>>
        + Shuffling(TableSnapshot_Shuffling)
        + Dealing(TableSnapshot_Dealing)
        + Preflop(TableSnapshot_Preflop)
        + Flop(TableSnapshot_Flop)
        + Turn(TableSnapshot_Turn)
        + River(TableSnapshot_River)
        + Showdown(TableSnapshot_Showdown)
        + Complete(TableSnapshot_Complete)
    }

    class TableSnapshot_Shuffling {
        + game_id: GameId
        + hand_id: Option<HandId>
        + cfg: Option<HandConfig>
        + shufflers: Vec<Shuffler>
        + players: PlayerRoster
        + seating: SeatingMap
        + stacks: PlayerStacks
        + shuffling: ShufflingSnapshot
    }

    class TableSnapshot_Dealing {
        + game_id: GameId
        + hand_id: Option<HandId>
        + cfg: Option<HandConfig>
        + shufflers: Vec<Shuffler>
        + players: PlayerRoster
        + seating: SeatingMap
        + stacks: PlayerStacks
        + shuffling: ShufflingSnapshot
        + dealing: DealingSnapshot
    }

    class ShufflingSnapshot {
        + initial_deck: [ElGamalCiphertext; 52]
        + steps: Vec<ShufflingStep>
        + final_deck: [ElGamalCiphertext; 52]
    }

    class ShufflingStep {
        + shuffler_public_key: CurvePoint
        + proof: ShuffleProof
    }

    class DealingSnapshot {
        + assignments: BTreeMap<CardRef, DealtCard>
        + player_ciphertexts: BTreeMap<(SeatId, HoleIndex), PlayerAccessibleCiphertext>
        + player_blinding_contribs: BTreeMap<(ShufflerId, SeatId, HoleIndex), PlayerTargetedBlindingContribution>
        + community_decryption_shares: BTreeMap<(ShufflerId, CardRef), CommunityDecryptionShare>
        + community_cards: BTreeMap<CardRef, CardIndex>
        + card_plan: CardPlan
    }

    class BettingSnapshot {
        + state: BettingState
        + last_events: Vec<PlayerActionEvent>
    }

    class RevealsSnapshot {
        + board: Vec<CardIndex>
        + revealed_holes: BTreeMap<SeatId, RevealedHand>
    }

    class PlayerStackInfo {
        + seat: SeatId
        + player_id: Option<PlayerId>
        + starting_stack: u64
        + committed_blind: u64
        + status: PlayerStatus
    }

    class CardDestination {
        <<enum>>
        + Hole(seat, hole_index)
        + Board(board_index)
        + Burn
        + Unused
    }

    class CardPlan {
        <<typedef>>
        BTreeMap<CardRef, CardDestination>
    }

    class PlayerStacks {
        <<typedef>>
        BTreeMap<SeatId, PlayerStackInfo>
    }

    class VerifiedEnvelope {
        + key: NonceKey
        + nonce: u64
        + phase: HandStatus
        + message: LedgerMessage
        + raw: ActionEnvelope
    }

    class GameShuffleMessage {
        + deck_in: Vec<u8>
        + deck_out: Vec<u8>
        + proof: Vec<u8>
    }

    class LedgerMessage {
        <<enum>>
        + Shuffle(GameShuffleMessage)
        + Blinding(...)
        + PartialUnblinding(...)
        + PlayerPreflop(...)
        + PlayerFlop(...)
        + PlayerTurn(...)
        + PlayerRiver(...)
        + Showdown(...)
    }

    class LedgerTransition {
        + apply_transition(snapshot, envelope): Result<AnyTableSnapshot>
    }

    LedgerState --> AnyTableSnapshot
    AnyTableSnapshot --> TableSnapshot_Shuffling
    AnyTableSnapshot --> TableSnapshot_Dealing
    TableSnapshot_Dealing --> DealingSnapshot
    TableSnapshot_Dealing --> ShufflingSnapshot
    TableSnapshot_Shuffling --> ShufflingSnapshot
    DealingSnapshot --> CardPlan
    CardPlan --> CardDestination
    PlayerStacks --> PlayerStackInfo
    LedgerMessage --> GameShuffleMessage
    VerifiedEnvelope --> LedgerMessage
    LedgerTransition --> AnyTableSnapshot
    LedgerTransition --> VerifiedEnvelope
